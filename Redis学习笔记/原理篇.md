# 原理篇

<!-- TOC -->

- [原理篇](#原理篇)
    - [IO模型](#io模型)
        - [同步与异步](#同步与异步)
        - [阻塞与非阻塞](#阻塞与非阻塞)
        - [组合模型](#组合模型)
    - [IO复用](#io复用)
        - [IO多路复用](#io多路复用)
            - [select 模型](#select-模型)
            - [poll模型](#poll模型)
            - [epoll模型](#epoll模型)
    - [redis单线程](#redis单线程)
    - [redis通信协议](#redis通信协议)
    - [持久化](#持久化)
        - [是什么](#是什么)
        - [Fork](#fork)
        - [RDB](#rdb)
        - [AOF](#aof)
        - [其他备注：](#其他备注)

<!-- /TOC -->

## IO模型

### 同步与异步
同步与异步的理解同步与异步的重点在消息通知的方式上，也就是调用结果通知的方式。

同步: 
> 当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行。

异步：
>当一个异步调用发出去后，调用者不能立即得到调用结果的返回。

异步调用，要想获得结果，一般有两种方式：
>1. 主动轮询异步调用的结果;
>2. 被调用方通过callback来通知调用方调用结果。


### 阻塞与非阻塞
阻塞与非阻塞的重点在于进/线程等待消息时候的行为，也就是在等待消息的时候，当前进/线程是挂起状态，还是非挂起状态。

阻塞调用:
>在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活.

非阻塞调用:
>在发出去后，不会阻塞当前进/线程，而会立即返回。

### 组合模型

* **同步阻塞**：小明在柜台干等着拿奶茶；
* **同步非阻塞**：小明在柜台边刷微博边等着拿奶茶；
* **异步阻塞**：小明拿着小票啥都不干，一直等着店员通知他拿奶茶；
* **异步非阻塞**：小明拿着小票，刷着微博，等着店员通知他拿奶茶。



## IO复用

第一种方法就是最传统的多进程并发模型 (每进来一个新的I/O流会分配一个新的进程管理。)

第二种方法就是I/O多路复用 (单个线程，通过记录跟踪每个I/O流(sock)的状态，来同时管理多个I/O流 。)



### IO多路复用


#### select 模型
- 内容待补充

#### poll模型
- 内容待补充

#### epoll模型
- 内容待补充



## redis单线程
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型

它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理

![](https://raw.githubusercontent.com/Syncma/Figurebed/master/img/redis-single-thread-model.png)


## redis通信协议

RESP



## 持久化

Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。

### 是什么
在指定的时间间隔内将内存中的数据集快照写入磁盘
也就是行话说的**`snapshot快照，它恢复时是将快照文件直接读到内存中`**

redis 会单独创建(Fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件

整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能

如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，
那RDB方式要比AOF方式更加的高效

**`RDB的缺点就是最后一次持久化后的数据可能丢失`**

### Fork
**Fork的作用是复制一个与当前进程一样的进程**

新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程


### RDB

1.**`RDB保存的是dump.rdb文件`**

2.配置位置 ：redis.conf 文件里面**`SNAPSHOTING`**

```
1)Save:
save  秒钟  写操作次数
默认：
1分钟内修改1万次
5分钟内修改10次
15分钟修改1次

禁用 ： 只要不设置任何save指令，或者给save传入一个空字符串参数
2)Stop-writes-on-bgsave-error
默认是yes, 如果设置为no, 表示你不在乎数据不一致或者有其他的手段发现和控制
3)rdbcompression
对于存储到磁盘中的快照，可以设置是否进行压缩存储
默认是yes,  表示会采用LZF算法进行压缩
如果不想消耗CPU来进行压缩的话，可以设置为关闭此功能
4)rdbchecksum
在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大于10%的性能消耗
默认是yes, 如果希望获取到最大的性能提升，可以关闭此功能
5)dbfilename
6)dir

```
3.如何触发RDB快照

配置文件中默认的快照配置 ； 冷拷贝后重新使用 可以cp dump.rdb dump_new.rdb

**`命令save 或者bgsave`**
```
Save: save时只管保存，其他不管，全部阻塞
Bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。
可以通过lastsave命令获取最后一次成功执行快照的时间
```


4.如何恢复
执行了flushall命令，也会产生dump.rdb文件，但是里面是空的

只要吧备份后的rdb文件 替换以前的  就可以了，  名字变成dump.rdb

移动到redis安装目录并启动服务即可

5.RDB文件路径可以使用

**CONFIG get dir 命令** 

6.优势
```
1）适合大规模的数据恢复
2）对数据完整性和一致性要求不高
```

7.劣势
```
1）在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改
2）Fork的时候，内存中的数据被克隆了一份，**大致2倍的膨胀性需要考虑**
```

8.如何停止
只要不设置任何save指令，或者给save传入一个空字符串参数

动态所有停止RDB保存规则的方法： **`redis-cli config set save` **


9.总结

![](https://raw.githubusercontent.com/Syncma/Figurebed/master/img/RDB.png)

### AOF


1.是什么
**将写命令添加到 AOF 文件（Append Only File）的末尾。**

以日志的形式来记录每个写操作， 将redis执行过的所有写指令记录下来（读操作不记录），
只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据

换言之，**redis重启的话就根据日志文件的内容将写命令从前到后执行一次以完成数据的恢复工作**


2.AOF保存的是**`appendonly.aof`**文件


3.配置位置

redis.conf 文件里面**`APPEND ONLY MODE`**

```
appendonly
appendfilename
Appendfsync 
	1. Always: 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好
	2. Everysec: 出厂默认推荐，异步操作，每秒记录，如果一秒内宕机，有数据丢失
	3. No  

No-appendfsync-on-rewrite  重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性
Auto-aof-rewrite-min-size   设置重写的基准值
Auto-aof-rewrite-percentage  设置重写的基准值
```

4.AOF启动/修复/恢复

1）正常恢复
```
启动：设置yes， 修改默认的appendony no 改成yes
将有数据的aof 文件复制一份保存到对应目录 (config get dir)
恢复：重启redis然后重新加载
```


2）异常恢复
```
启动： 设置yes
备份被写坏的AOF文件
修复： redis-check-aof --fix 进行恢复
恢复：重启redis然后重新加载
```


5.Rewrite

```
1）是什么

AOF采用文件追加方式，文件会越来越大
为避免出现这种情况，新增了重写机制

当AOF文件的大小超过所设定的阙值时，Redis就会启动AOF文件的内容压缩，
且保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof

2）重写原理

AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename)
遍历新进程的内存中数据，每条记录有一条的set语句。

重写AOF文件的操作，并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写一个新的AOF文件

类似快照

3）触发机制

Redis会记录上次重写时候的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发

就是这两个参数：

Auto-aof-rewrite-min-size   设置重写的基准值
Auto-aof-rewrite-percentage  设置重写的基准值
```


6.优势

```
1）每秒同步： appendfsync always 
同步持久化，每次发送数据变更会立即记录到磁盘

2）每修改同步：appendfsync everysec
异步操作，每秒操作，如果一秒内宕机，有数据丢失

3）不同步  appendfsync no 
从不同步
```


7.劣势

```
1）相同数据集的数据而言，aof 文件要远大于rdb文件，恢复速度慢于rdb
2）AOF运行效率要慢于RDB， 每秒同步策略效率较好，不同步效率和rdb相同
```

8.总结
![](https://raw.githubusercontent.com/Syncma/Figurebed/master/img/AOF.png)

### 其他备注：

1.redis 内存占用分配

* 如果要做持久化  内存占用就是系统内存的一半左右
* 不持久化，内存可以稍大点，80%左右


2.注意：
**`如果AOF文件存在， redis启动会先读aof文件， 如果aof文件错误 会导致服务启动失败`**

3.问题选择哪一种呢？

1）官问建议

2）RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储

3）AOF持久化记录每次对服务器写的操作

```
当服务器重启的时候会重新执行这些命令来恢复原始的数据
AOF 命令以redis协议追加保存每次写的操作到文件末尾
Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大
```

4）只做缓存
如果你只希望你的数据在服务器运行的时候存在，也可以不使用任何持久化方式

5）**`同时开启两种持久化方式`**

在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，
因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整
RDB的数据不实时，同时使用两者时服务器重写也只会找AOF文件

那要不要只使用AOF呢？
建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份）
快速重启、而且不会有AOF可能潜在的bug，留着作为一个万一的手段

总结： **bgsave做镜像全量持久化，aof做增量持久化**


6）性能建议


![](https://raw.githubusercontent.com/Syncma/Figurebed/master/img/20200113153136.png)


